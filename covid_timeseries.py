# -*- coding: utf-8 -*-
"""Covid_timeseries.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t0hQ3RNlAgtST5YcAgfISoQdFVZAEvZf
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
# import selenium
# from selenium import webdriver

# def get_link_urls(url,driver):
#     driver.get(url)
#     urls = []
#     for link in d.find_elements_by_tag_name('a'):
#         urls.append(link.get_attribute('href'))
#     return urls

# d = webdriver.Safari()
# urls = get_link_urls("http://localhost:8080", d)
# sub_urls = []
# for url in urls:
#     sub_urls.extend(get_link_urls(url))
import sklearn

df2 = pd.read_csv('c19.csv')
print(df2.head())
print(df2.shape)

print(df2['Date'])

df2['Date'] = pd.to_datetime(df2['Date']).dt.date
df2['HCC'] = df2['HospitalisedCovidCases'].fillna(0)

# for index, row in df2.iterrows():
#     print(index, row['Date'], row['HCC'])

# d = df2['Date'][0]
prev_num = 0
df2['new_HCC'] = df2['HCC']
for index,row in df2.iterrows():
  df2.at[index, 'new_HCC'] = row['HCC'] - prev_num
  prev_num = row['HCC']
  # print(prev_num)
  # print(index, row['Date'], row['HCC'], df2.at[index, 'new_HCC'])

# print(df2['new_HCC'])
# print(df2.columns)
plt.plot(df2['Date'], df2['new_HCC'])

# i_range = []
# for i in range(293,400):
#   i_range.append(df2.Index[i, 'new_HCC'])

plt.plot(df2.iloc[200:638,42])
plt.show()

print("")

start=pd.to_datetime(df2['Date'][200])
print("Start: ", start)
end=pd.to_datetime(df2['Date'][638])
print("End: ", end)
t_full=pd.array(pd.DatetimeIndex(df2.iloc[200:638,2])).astype(np.int64)
print("Tfull: ", t_full)
dt = t_full[2] - t_full[1]
print("Data sampling interval", dt)

t = (t_full[33]-t_full[32])/60/60/24
print(t)
ss = pd.array(pd.Index(df2.iloc[200:638,42])).astype(np.int64)
og_ss = ss
print(og_ss.size)
plt.plot(df2.iloc[200:638, 2], ss)
plt.show()

stride = 1
lag = 2 #determines the feature vector size
dd = 1 #number of samples in a day
q = 1
XX = og_ss[0:og_ss.size - q - lag * dd:stride]
for i in range(1,lag):
  X = og_ss[i*dd:og_ss.size - q - (lag-i)*dd:stride]
  XX = np.column_stack((XX,X))
  # print(XX.size) #will be size = lag * X_size
yy = og_ss[lag*dd+q::stride] #size of XX before column stacking
# print("SS:",ss.size)
# print("yy:",yy.size)
tt = t_full[lag*dd+q::stride]
  # print(tt.size)
from sklearn.model_selection import train_test_split, TimeSeriesSplit

train, test = train_test_split(np.arange(0,yy.size),test_size=0.2)

from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
model = Lasso(fit_intercept=False, alpha=0).fit(XX[train], yy[train])
  # print(model.intercept_, model.coef_)

y_pred = model.predict(XX)

plt.rcParams["figure.figsize"] = (25,10)
plt.plot(t_full, og_ss, color='black')
plt.plot(tt, y_pred, color='blue')
plt.show()

from sklearn.metrics import mean_squared_error
mse = mean_squared_error(yy, y_pred)
rmse = math.sqrt(mse)
print("mse:", rmse)

def train_predict_Ridge(q_step, stride, lag, dd):
  # stride = stride
  # lag = lag #determines the feature vector size
  # dd = dd #number of samples in a day
  q = 1
  ss = og_ss
  og_tt = t_full[lag*dd+q::stride]
  day_sec = 86400000000000
  for j in range(0,q_step*day_sec, day_sec):
    XX = ss[0:ss.size - q - lag * dd:stride]
    for i in range(1,lag):
      X = ss[i*dd:ss.size - q - (lag-i)*dd:stride]
      XX = np.column_stack((XX,X))
    # print(XX.size) #will be size = lag * X_size
    yy = ss[lag*dd+q::stride] #size of XX before column stacking
    # print("SS:",ss.size)
    # print("yy:",yy.size)
    tt = t_full[lag*dd+q::stride]
    # print(tt.size)
    from sklearn.model_selection import train_test_split
    train, test = train_test_split(np.arange(0,yy.size),test_size=0.2)

    from sklearn.linear_model import Ridge
    model = Ridge(fit_intercept=True, alpha=5).fit(XX[train], yy[train])
    # print(model.intercept_, model.coef_)

    y_pred = model.predict(XX)
    yp = y_pred[y_pred.size-1]
    ss = np.append(ss, yp)
    np.append(tt, tt[tt.size-1] + day_sec)
    # print("tt:",tt.size)

  # print("XX:" ,XX.size)
  tscv = TimeSeriesSplit()
  TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)
  mean_error = []
  std_error = []
  C = [1, 5, 10, 30, 50]
  for train_index, test_index in tscv.split(XX):
    temp = []
    temp2 =[]
    for Ci in C:
      model = Ridge(fit_intercept=True, alpha=Ci)
      model.fit(XX[train_index], yy[train_index])
      y_pred = model.predict(XX[test_index])
      temp.append(sklearn.metrics.mean_squared_error(yy[test_index], y_pred))
      temp2.append(sklearn.metrics.mean_absolute_error(yy[test_index], y_pred))
    mean_error.append(np.array(temp).mean())
    std_error.append(np.array(temp2).std())
  plt.xlim((0, 50))
  plt.errorbar(C, mean_error, yerr=std_error)
  plt.xlabel('Ci')
  print(mean_error)
  print(std_error)
  # plt.xticks(np.arange(0, 1, step=0.2))
  plt.xticks([1, 5, 10, 30, 50])
  plt.ylabel('Mean squared error')
  plt.title('Mean squared error and Standard deviance for C values in Ridge')

  plt.show()
  y_pred_2 = model.predict(XX)
  # print("tfull:",t_full)
  tt_full2 = np.arange(t_full[t_full.size-1], t_full[t_full.size-1] + q_step*day_sec, day_sec)
  pred_num = tt_full2.size
  # print("ttfull2:",tt_full2)
  plt.rcParams["figure.figsize"] = (25,10)
  plt.plot(t_full, og_ss, color='black')
  t_full_dates = pd.to_datetime(tt_full2)
  # print(t_full_dates)
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()

  from sklearn.metrics import mean_squared_error
  mse = mean_squared_error(yy, y_pred_2)
  rmse = math.sqrt(mse)
  return rmse

rmse_30 = train_predict_Ridge(30, 1, 2, 1)
print("RMSE: ", rmse_30)

rmse_200 = train_predict_Ridge(200,1,3,1)
print("RMSE 100 days: ", rmse_200)

def train_predict_Lasso(q_step, stride, lag, dd):
  # stride = stride
  # lag = lag #determines the feature vector size
  # dd = dd #number of samples in a day
  q = 1
  ss = og_ss
  og_tt = t_full[lag*dd+q::stride]
  day_sec = 86400000000000
  for j in range(0,q_step*day_sec, day_sec):
    XX = ss[0:ss.size - q - lag * dd:stride]
    for i in range(1,lag):
      X = ss[i*dd:ss.size - q - (lag-i)*dd:stride]
      XX = np.column_stack((XX,X))
    # print(XX.size) #will be size = lag * X_size
    yy = ss[lag*dd+q::stride] #size of XX before column stacking
    # print("SS:",ss.size)
    # print("yy:",yy.size)
    tt = t_full[lag*dd+q::stride]
    # print(tt.size)
    from sklearn.model_selection import train_test_split
    train, test = train_test_split(np.arange(0,yy.size),test_size=0.2)

    from sklearn.linear_model import Lasso
    model = Lasso(fit_intercept=True, alpha=10).fit(XX[train], yy[train])
    # print(model.intercept_, model.coef_)

    y_pred = model.predict(XX)
    yp = y_pred[y_pred.size-1]
    ss = np.append(ss, yp)
    np.append(tt, tt[tt.size-1] + day_sec)
    # print("tt:",tt.size)
    # print("XX:" ,XX.size)

  tscv = TimeSeriesSplit()
  TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)
  mean_error = []
  std_error = []
  C = [1, 10, 100, 500,1000]
  for train_index, test_index in tscv.split(XX):
    temp = []

    for Ci in C:
      model = Lasso(fit_intercept=True, alpha=Ci)
      model.fit(XX[train_index], yy[train_index])
      y_pred = model.predict(XX[test_index])
      temp.append(sklearn.metrics.mean_squared_error(yy[test_index], y_pred))
    mean_error.append(np.array(temp).mean())
    std_error.append(np.array(temp).std())
  plt.xlim((0, 1000))
  plt.errorbar(C, mean_error, yerr=std_error)
  plt.xlabel('Ci')
  print(mean_error)
  print(std_error)
  # plt.xticks(np.arange(0, 1, step=0.2))
  plt.xticks([1, 10, 100, 500,1000])
  plt.ylabel('Mean squared error')
  plt.title('Mean squared error and Standard deviance for C values in Lasso')

  plt.show()
  y_pred_2 = model.predict(XX)
  # print("tfull:",t_full)
  tt_full2 = np.arange(t_full[t_full.size-1], t_full[t_full.size-1] + q_step*day_sec, day_sec)
  pred_num = tt_full2.size
  # print("ttfull2:",tt_full2)
  plt.rcParams["figure.figsize"] = (25,10)
  plt.plot(t_full, og_ss, color='black')
  t_full_dates = pd.to_datetime(tt_full2)
  # print(t_full_dates)
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()

  from sklearn.metrics import mean_squared_error
  mse = mean_squared_error(yy, y_pred_2)
  rmse = math.sqrt(mse)
  return rmse

rmse_lasso_200 = train_predict_Lasso(200, 1, 2, 1)
print("RMSE lasso 200:", rmse_lasso_200)







def train_predict_Dummy(q_step, stride, lag, dd):
  # stride = stride
  # lag = lag #determines the feature vector size
  # dd = dd #number of samples in a day
  q = 1
  ss = og_ss
  og_tt = t_full[lag*dd+q::stride]
  day_sec = 86400000000000
  for j in range(0,q_step*day_sec, day_sec):
    XX = ss[0:ss.size - q - lag * dd:stride]
    for i in range(1,lag):
      X = ss[i*dd:ss.size - q - (lag-i)*dd:stride]
      XX = np.column_stack((XX,X))
    # print(XX.size) #will be size = lag * X_size
    yy = ss[lag*dd+q::stride] #size of XX before column stacking
    # print("SS:",ss.size)
    # print("yy:",yy.size)
    tt = t_full[lag*dd+q::stride]
    # print(tt.size)
    from sklearn.model_selection import train_test_split
    train, test = train_test_split(np.arange(0,yy.size),test_size=0.2)

    from sklearn.dummy import DummyRegressor
    model = DummyRegressor().fit(XX[train], yy[train])
    # print(model.intercept_, model.coef_)

    y_pred = model.predict(XX)
    yp = y_pred[y_pred.size-1]
    ss = np.append(ss, yp)
    np.append(tt, tt[tt.size-1] + day_sec)
    # print("tt:",tt.size)
    # print("XX:" ,XX.size)

  y_pred_2 = model.predict(XX)
  # print("tfull:",t_full)
  tt_full2 = np.arange(t_full[t_full.size-1], t_full[t_full.size-1] + q_step*day_sec, day_sec)
  pred_num = tt_full2.size
  # print("ttfull2:",tt_full2)
  plt.rcParams["figure.figsize"] = (25,10)
  plt.plot(t_full, og_ss, color='black')
  t_full_dates = pd.to_datetime(tt_full2)
  # print(t_full_dates)
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()

  from sklearn.metrics import mean_squared_error
  mse = mean_squared_error(yy, y_pred_2)
  rmse = math.sqrt(mse)
  return rmse

rmse_dummy_200 = train_predict_Dummy(200, 1, 2, 1)
print("RMSE dummy 200:", rmse_dummy_200)










def train_predict_LR(q_step, stride, lag, dd):
  # stride = stride
  # lag = lag #determines the feature vector size
  # dd = dd #number of samples in a day
  q = 1
  ss = og_ss
  og_tt = t_full[lag*dd+q::stride]
  day_sec = 86400000000000
  for j in range(0,q_step*day_sec, day_sec):
    XX = ss[0:ss.size - q - lag * dd:stride]
    for i in range(1,lag):
      X = ss[i*dd:ss.size - q - (lag-i)*dd:stride]
      XX = np.column_stack((XX,X))
    # print(XX.size) #will be size = lag * X_size
    yy = ss[lag*dd+q::stride] #size of XX before column stacking
    # print("SS:",ss.size)
    # print("yy:",yy.size)
    tt = t_full[lag*dd+q::stride]
    # print(tt.size)
    from sklearn.model_selection import train_test_split
    train, test = train_test_split(np.arange(0,yy.size),test_size=0.2)

    from sklearn.linear_model import LogisticRegression
    #model = LogisticRegression(fit_intercept=True, penalty='l2', max_iter= 9999999999).fit(XX[train], yy[train])
    # print(model.intercept_, model.coef_)

    # y_pred = model.predict(XX)
    # yp = y_pred[y_pred.size-1]
    # ss = np.append(ss, yp)
    # np.append(tt, tt[tt.size-1] + day_sec)
    # print("tt:",tt.size)
  tscv = TimeSeriesSplit()
  TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None)
  mean_error = []
  std_error = []
  C = [0.001, 0.005, 0.01, 0.1, 0.2]
  for Ci in C:
    temp = []
    model1 = LogisticRegression(fit_intercept=True, penalty='l2', max_iter=100000, C=Ci)
    for train_index, test_index in tscv.split(XX):
      model1.fit(XX[train_index], yy[train_index])
      y_pred = model1.predict(XX[test_index])
      temp.append(sklearn.metrics.mean_squared_error(yy[test_index], y_pred))
    mean_error.append(np.array(temp).mean())
    std_error.append(np.array(temp).std())
  plt.xlim((0, 0.2))
  plt.errorbar(C, mean_error, yerr=std_error)
  plt.xlabel('Ci')
  # plt.xticks(np.arange(0, 1, step=0.2))
  plt.xticks([0.001, 0.005, 0.01, 0.1, 0.2])
  plt.ylabel('Mean squared error')
  plt.title('Mean squared error and Standard deviance for C values in LR')

  plt.show()
  # print("XX:" ,XX.size)

  y_pred_2 = model.predict(XX)
  # print("tfull:",t_full)
  tt_full2 = np.arange(t_full[t_full.size-1], t_full[t_full.size-1] + q_step*day_sec, day_sec)
  pred_num = tt_full2.size
  # print("ttfull2:",tt_full2)
  plt.rcParams["figure.figsize"] = (25,10)
  plt.plot(t_full, og_ss, color='black')
  t_full_dates = pd.to_datetime(tt_full2)
  # print(t_full_dates)
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()
  plt.plot(tt_full2, y_pred_2[:q_step], color='blue')
  plt.xticks(tt_full2, labels=t_full_dates)
  plt.show()

  from sklearn.metrics import mean_squared_error
  mse = mean_squared_error(yy, y_pred_2)
  rmse = math.sqrt(mse)
  return rmse

rmse_lr_200 = train_predict_LR(10, 1, 2, 1)
print("rmse lr 200:", rmse_lr_200)

from matplotlib import pyplot
from statsmodels.tsa.seasonal import seasonal_decompose
result = seasonal_decompose(df2.iloc[:,42], model='additive', period=1)
result.plot()
pyplot.show()
print(result.trend)
print(result.seasonal)
print(result.resid)
print(result.observed)



from matplotlib import pyplot
from statsmodels.tsa.seasonal import seasonal_decompose
result = seasonal_decompose(df2.iloc[:,42], model='additive', period=7)
result.plot()
pyplot.show()
print(result.trend)
print(result.seasonal)
print(result.resid)
print(result.observed)



from matplotlib import pyplot
from statsmodels.tsa.seasonal import seasonal_decompose
result = seasonal_decompose(df2.iloc[:,42], model='additive', period=30)
result.plot()
pyplot.show()
print(result.trend)
print(result.seasonal)
print(result.resid)
print(result.observed)